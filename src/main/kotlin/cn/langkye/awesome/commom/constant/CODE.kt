package cn.langkye.awesome.commom.constant

/**
 * http code:
 * @doc https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81
 * @doc https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
 * */
object CODE {
    /**成功*/
    object SUCCESS {
        val MESSAGE : String = "成功";

        /**
         * 请求已成功，请求所希望的响应头或数据体将随此响应返回。
         * 实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。
         * 在POST请求中，响应将包含描述或操作结果的实体。*/
        val OK: Int = 200

        /**
         * 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。
         * 假如需要的资源无法及时创建的话，应当返回'202 Accepted'。*/
        val CREATED: Int = 201

        /**
         * 服务器已接受请求，但尚未处理。
         * 最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。*/
        val ACCEPTED: Int = 202

        /**服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。*/
        val NON_AUTHORITATIVE_INFORMATION: Int = 203

        /**服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。*/
        val NO_CONTENT: Int = 204
        //...
    }

    /**重定向*/
    object REDIRECT {
        val MESSAGE : String = "重定向";

        /**
         * 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。
         * 用户或浏览器能够自行选择一个首选的地址进行重定向。[17]
         * 除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。
         * 这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。
         * 当然，RFC 2616规范并没有规定这样的自动选择该如何进行。
         * 如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。
         * 此外，除非额外指定，否则这个响应也是可缓存的。*/
        val MULTIPLE_CHOICES: Int = 300

        /**
         * 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。
         * 如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。
         * [18]除非额外指定，否则这个响应也是可缓存的。
         * 新的永久性的URI应当在响应的Location域中返回。
         * 除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
         * 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
         * 注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。*/
        val MOVED_PERMANENTLY: Int = 301

        /**
         * 要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。
         * [19]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。
         * 只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
         * 新的临时性的URI应当在响应的Location域中返回。
         * 除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
         * 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
         * 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。
         * [20]因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。*/
        val FOUND: Int = 302

        /**
         * 对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。
         * 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。
         * 这个新的URI不是原始资源的替代引用。
         * 同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。
         * 新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
         * 注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。*/
        val SEE_OTHER: Int = 303

        /**表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。*/
        val NOT_MODIFIED: Int = 304
        //...
    }

    /**客户端错误*/
    object CLIENT_ERROR {
        val MESSAGE : String = "客户端错误";

        /**由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。*/
        val BAD_REQUEST: Int = 400

        /**
         * 类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。
         * [31]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。
         * 客户端可以重复提交一个包含恰当的Authorization头信息的请求。
         * [32]如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。
         * 如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
         * 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。*/
        val UNAUTHORIZED: Int = 401

        /**
         * 该状态码是为了将来可能的需求而预留的。
         * 该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。
         * 如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。*/
        val PAYMENT_REQUIRED: Int = 402

        /**
         * 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。
         * 如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。
         * 当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。*/
        val FORBIDDEN: Int = 403

        /**请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[34]没有信息能够告诉用户这个状况到底是暂时的还是永久的。
         * 假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。
         * 404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。*/
        val NOT_FOUND: Int = 404

        /**
         * 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。
         * 例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。
         * 鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。*/
        val METHOD_NOT_ALLOWED: Int = 405

        /**请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。[35]
         * 除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址栏表的实体。
         * 实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。
         * 但是，规范中并没有定义任何作出此类自动选择的标准。*/
        val NOT_ACCEPTABLE: Int = 406
        //...
    }

    /**服务器错误*/
    object SERVER_ERROR {
        val MESSAGE : String = "服务器错误";

        /**通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。*/
        val INTERNAL_SERVER_ERROR: Int = 500

        /**服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。[59]（例如，网络服务API的新功能）*/
        val NOT_IMPLEMENTED: Int = 501

        /**作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。*/
        val BAD_GATEWAY: Int = 502

        /**
         * 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。
         * [61]如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。
         * 如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。*/
        val SERVICE_UNAVAILABLE: Int = 503

        /**
         * 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。[62]
         * 注意：某些代理服务器在DNS查询超时时会返回400或者500错误。*/
        val GATEWAY_TIMEOUT: Int = 504

        /**服务器不支持，或者拒绝支持在请求中使用的HTTP版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。*/
        val HTTP_VERSION_NOT_SUPPORTED: Int = 505

        /**由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，[64]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。*/
        val VARIANT_ALSO_NEGOTIATES: Int = 406
        //...
    }
}
